import sys
import threading
import time
import random
import sqlite3
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                             QLabel, QRadioButton, QPushButton, QTextEdit,
                             QInputDialog, QMessageBox, QTreeWidget,
                             QTreeWidgetItem, QHBoxLayout)
from PyQt5.QtCore import Qt, pyqtSignal, QObject


class DatabaseApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gestion Lecteurs/Rédacteurs")
        self.setup_ui()
        self.conn = self.connection_setup()

    def connection_setup(self):
        conn = sqlite3.connect('database.db', check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute("CREATE TABLE IF NOT EXISTS data (value INTEGER)")
        conn.commit()
        return conn

    def setup_ui(self):
        # Widget central
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Layout principal
        layout = QVBoxLayout()
        central_widget.setLayout(layout)

        # Sélection du scénario
        layout.addWidget(QLabel("Choisissez un scénario:"))

        self.scenario1 = QRadioButton("Priorité absolue aux lecteurs")
        self.scenario2 = QRadioButton("Priorité aux lecteurs si actif")
        self.scenario3 = QRadioButton("Priorité aux rédacteurs")

        layout.addWidget(self.scenario1)
        layout.addWidget(self.scenario2)
        layout.addWidget(self.scenario3)

        # Boutons
        self.start_btn = QPushButton("Démarrer la simulation")
        self.start_btn.clicked.connect(self.start_simulation)
        layout.addWidget(self.start_btn)

        self.view_data_btn = QPushButton("Voir les données")
        self.view_data_btn.clicked.connect(self.show_data)
        layout.addWidget(self.view_data_btn)

        # Console de sortie
        self.output = QTextEdit()
        self.output.setReadOnly(True)
        layout.addWidget(self.output)

        # Configuration de la fenêtre
        self.resize(600, 400)

    def log(self, message):
        self.output.append(message)

    def lire_donnee(self, id_lecteur):
        cursor = self.conn.cursor()
        cursor.execute("SELECT value FROM data ORDER BY ROWID DESC LIMIT 1")
        result = cursor.fetchone()
        valeur = result[0] if result else "Aucune donnée"
        self.log(f"Lecteur {id_lecteur} a lu: {valeur}")
        return valeur

    def ecrire_donnee(self, id_redacteur):
        valeur, ok = QInputDialog.getInt(
            self,
            f"Rédacteur {id_redacteur}",
            "Entrez un nombre à écrire:",
            0, -2147483648, 2147483647, 1
        )

        if ok:
            cursor = self.conn.cursor()
            cursor.execute("INSERT INTO data (value) VALUES (?)", (valeur,))
            self.conn.commit()
            self.log(f"Rédacteur {id_redacteur} a écrit: {valeur}")
            return True
        return False

    def start_simulation(self):
        if not (self.scenario1.isChecked() or
                self.scenario2.isChecked() or
                self.scenario3.isChecked()):
            QMessageBox.warning(self, "Attention", "Veuillez sélectionner un scénario")
            return

        self.output.clear()

        if self.scenario1.isChecked():
            self.case1()
        elif self.scenario2.isChecked():
            self.case2()
        elif self.scenario3.isChecked():
            self.case3()

    def case1(self):
        self.w = threading.Semaphore(1)
        self.mutex1 = threading.Semaphore(1)
        self.mutex2 = threading.Semaphore(1)
        self.nl = 0

        def lecteur(id):
            nonlocal self
            self.log_signal.emit(f"Lecteur {id} veut lire")
            self.mutex1.acquire()
            self.nl += 1
            if self.nl == 1:
                self.w.acquire()
            self.mutex1.release()

            self.lire_signal.emit(id)
            time.sleep(random.uniform(0.5, 1.5))

            self.mutex1.acquire()
            self.nl -= 1
            if self.nl == 0:
                self.w.release()
            self.mutex1.release()
            self.log_signal.emit(f"Lecteur {id} a fini de lire")

        def redacteur(id):
            self.log_signal.emit(f"Rédacteur {id} veut écrire")
            self.mutex2.acquire()
            self.w.acquire()

            # Utilisation d'un signal pour la boîte de dialogue
            self.write_signal.emit(id)
            time.sleep(random.uniform(1, 2))

            self.w.release()
            self.mutex2.release()
            self.log_signal.emit(f"Rédacteur {id} a fini d'écrire")

        self.run_threads(lecteur, redacteur)

    def case2(self):
        self.w = threading.Semaphore(1)
        self.mutex1 = threading.Semaphore(1)
        self.nl = 0

        def lecteur(id):
            nonlocal self
            self.log_signal.emit(f"Lecteur {id} veut lire")
            self.mutex1.acquire()
            self.nl += 1
            if self.nl == 1:
                self.w.acquire()
            self.mutex1.release()

            self.lire_signal.emit(id)
            time.sleep(random.uniform(0.5, 1.5))

            self.mutex1.acquire()
            self.nl -= 1
            if self.nl == 0:
                self.w.release()
            self.mutex1.release()
            self.log_signal.emit(f"Lecteur {id} a fini de lire")

        def redacteur(id):
            self.log_signal.emit(f"Rédacteur {id} veut écrire")
            self.w.acquire()

            self.write_signal.emit(id)
            time.sleep(random.uniform(1, 2))

            self.w.release()
            self.log_signal.emit(f"Rédacteur {id} a fini d'écrire")

        self.run_threads(lecteur, redacteur)

    def case3(self):
        self.w = threading.Semaphore(1)
        self.r = threading.Semaphore(1)
        self.mutex1 = threading.Semaphore(1)
        self.mutex2 = threading.Semaphore(1)
        self.nl = 0
        self.nr = 0

        def lecteur(id):
            nonlocal self
            self.log_signal.emit(f"Lecteur {id} veut lire")
            self.r.acquire()
            self.mutex1.acquire()
            self.nl += 1
            if self.nl == 1:
                self.w.acquire()
            self.mutex1.release()
            self.r.release()

            self.lire_signal.emit(id)
            time.sleep(random.uniform(0.5, 1.5))

            self.mutex1.acquire()
            self.nl -= 1
            if self.nl == 0:
                self.w.release()
            self.mutex1.release()
            self.log_signal.emit(f"Lecteur {id} a fini de lire")

        def redacteur(id):
            nonlocal self
            self.log_signal.emit(f"Rédacteur {id} veut écrire")
            self.mutex2.acquire()
            self.nr += 1
            if self.nr == 1:
                self.r.acquire()
            self.mutex2.release()

            self.w.acquire()
            self.write_signal.emit(id)
            time.sleep(random.uniform(1, 2))
            self.w.release()

            self.mutex2.acquire()
            self.nr -= 1
            if self.nr == 0:
                self.r.release()
            self.mutex2.release()
            self.log_signal.emit(f"Rédacteur {id} a fini d'écrire")

        self.run_threads(lecteur, redacteur)

    def run_threads(self, lecteur_func, redacteur_func):
        self.threads = []
        for i in range(3):  # 3 threads pour faciliter les tests
            if random.random() < 0.6:
                t = threading.Thread(target=lecteur_func, args=(i,))
            else:
                t = threading.Thread(target=redacteur_func, args=(i,))
            self.threads.append(t)
            t.start()
            time.sleep(random.uniform(0.1, 0.5))

    def show_data(self):
        cursor = self.conn.cursor()
        cursor.execute("SELECT rowid, value FROM data ORDER BY rowid")
        data = cursor.fetchall()

        dialog = QTreeWidget()
        dialog.setWindowTitle("Données enregistrées")
        dialog.setColumnCount(2)
        dialog.setHeaderLabels(["ID", "Valeur"])

        for row in data:
            item = QTreeWidgetItem(dialog)
            item.setText(0, str(row[0]))
            item.setText(1, str(row[1]))

        dialog.resize(400, 300)
        dialog.exec_()

    def closeEvent(self, event):
        if hasattr(self, 'conn'):
            self.conn.close()
        event.accept()


class Communicate(QObject):
    log_signal = pyqtSignal(str)
    lire_signal = pyqtSignal(int)
    write_signal = pyqtSignal(int)


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # Création des signaux
    communicator = Communicate()

    # Création de la fenêtre principale
    window = DatabaseApp()

    # Connexion des signaux
    communicator.log_signal.connect(window.log)


    def handle_lire(id):
        window.lire_donnee(id)


    communicator.lire_signal.connect(handle_lire)


    def handle_write(id):
        window.ecrire_donnee(id)


    communicator.write_signal.connect(handle_write)

    # Attribution des signaux à la fenêtre
    window.log_signal = communicator.log_signal
    window.lire_signal = communicator.lire_signal
    window.write_signal = communicator.write_signal

    window.show()
    sys.exit(app.exec_())
